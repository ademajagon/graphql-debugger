---
layout: docs
category: Documentation
permalink: /docs/why
next: /docs/why
---

# Why GraphQL Debugger ?

GraphQL servers are built and interacted with differently to that of other API servers. We found a bunch of pitfalls when using off the shelf tools to debug our GraphQL servers, and so we built GraphQL Debugger to solve these problems.

## HTTP Post Body

Most GraphQL implentations use `HTTP` `POST` requests to send queries to the server. The query is sent in the body of the request, for example querying the SpaceX API in the browser: 

```ts
const body = JSON.stringify({
  query: "{ missions { description payloads { payload_type }}}",
});

const response = await fetch("https://api.spacex.land/graphql/", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body, // <-- Notice the body
});

const { data, errors } = await response.json();
```

What this means for us debuggers and observers is that each request to our server will always be displayed as a `HTTP` `POST` request making it difficult to distinguish or filter between requests.

```sh
# Logs from a GraphQL server
HTTP POST /graphql 1 second ago
HTTP POST /graphql 2 seconds ago
HTTP POST /graphql 3 seconds ago
HTTP POST /graphql 4 seconds ago
HTTP POST /graphql 5 seconds ago
HTTP POST /graphql 6 seconds ago
HTTP POST /graphql 7 seconds ago
HTTP POST /graphql 8 seconds ago
...
```

For example, if you were using a REST API, you would expect to see a variety of `HTTP` methods such as `GET`, `POST`, `PUT`, `DELETE` etc, making it easier to debug and distinguish between requests.

```sh
# Logs from a REST server
HTTP GET /users 1 second ago
HTTP POST /users 2 seconds ago
HTTP PUT /users 3 seconds ago
HTTP DELETE /users 4 seconds ago
HTTP GET /users 5 seconds ago
HTTP POST /users 6 seconds ago
HTTP PUT /users 7 seconds ago
HTTP DELETE /users 8 seconds ago
```

## Resolver Fan Out

One given GraphQL query can result in many resolver functions being called and subsequently many database queries being executed. This is because GraphQL queries are hierarchical and the data is nested.

## HTTP Response 200

The HTTP response code is usually 200, and any errors are either a typed response or placed in the body errors list. 

## Schema Leverage

Given the fact that GraphQL is strongly typed, we can leverage the schema to provide a better debugging experience.